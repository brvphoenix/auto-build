name: CI

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build:
        description: 'Building pkgs'
        required: true
        type: boolean
      type:
        description: 'Building type'
        required: true
        default: 'all'
        type: choice
        options:
        - dynamic
        - static
        - all
      target:
        description: 'Target Name'
        required: true
        default: 'all'
        type: choice
        options:
        - x86
        - malta
        - ramips
        - bcm53xx
        - sunxi
        - mvebu
        - armsr
        - apm821xx
        - mpc85xx
        - sifiveu
        - all
      qt:
        description: 'QT version'
        required: true
        default: 'all'
        type: choice
        options:
        - 5
        - 6
        - all
      lt:
        description: 'libtorrent branch'
        required: true
        default: 'all'
        type: choice
        options:
        - 1.2
        - 2.0
        - all
      qbt:
        description: 'qbittorrent branch'
        required: true
        default: 'release'
        type: choice
        options:
        - release
        - master

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name }}-${{ format('{0}-{1}-{2}-{3}', github.event.inputs.type, github.event.inputs.target, github.event.inputs.qt, github.event.inputs.lt) }}
  cancel-in-progress: true

permissions:
  actions: write
  contents: write

jobs:
  build-prep:
    runs-on: ubuntu-latest
    outputs:
      draft: ${{ steps.create-draft.outcome }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      pkg: ${{ steps.set-matrix.outputs.pkg }}
      target: ${{ steps.set-matrix.outputs.target }}
    steps:
    - uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        [ -n "$(command -v jq)" ] || {
        	sudo apt-get update
        	sudo apt-get -y install jq
        }

    - name: Format build matrix
      id: set-matrix
      env:
        inputs_type: ${{ github.event.inputs.type }}
        inputs_target: ${{ github.event.inputs.target }}
        inputs_qt: ${{ github.event.inputs.qt }}
        inputs_lt: ${{ github.event.inputs.lt }}
      run: |
        bash ./scripts/gen_matrix.sh

    - name: Create draft
      id: create-draft
      if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        while [ "$(gh release list | cut -f 3 | grep -c '^'${GITHUB_REF_NAME}'$')" -ne 0 ]; do gh release delete "${GITHUB_REF_NAME}" -y; done
        gh release create -d --verify-tag --generate-notes -t "Release ${GITHUB_REF_NAME}" "${GITHUB_REF_NAME}"

  download-sdk:
    name: ${{ matrix.link }}, ${{ matrix.target }}
    needs: build-prep
    env:
      CUR_LINK_TYPE: ${{ matrix.link }}
      CUR_TARGET_NAME: ${{ matrix.target }}
      CUR_SDK_VERSION: ${{ matrix.USE_SDK_VERSION }}
      CUR_SDK_KEYRING: ${{ matrix.USE_SDK_KEYRING }}
      CUR_ROOTFS_VERSION: ${{ matrix.USE_ROOTFS_VERSION }}
      CUR_ROOTFS_KEYRING: ${{ matrix.USE_ROOTFS_KEYRING }}
      CUR_USE_IMAGEBUILDER: ${{ matrix.USE_IMAGEBUILDER }}
      CUR_RUNTIME_TEST: ${{ matrix.RUNTIME_TEST }}
      CUR_REPO_NAME: auto-build
      CUR_IB_DIR_NAME: imagebuilder
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.build-prep.outputs.target) }}
    steps:
    - uses: actions/checkout@v4
      with:
        path: ${{ env.CUR_REPO_NAME }}
        persist-credentials: false

    - name: Install Dependencies
      run: |
        [ -n "$(command -v curl)" -a -n "$(command -v jq)" ] || {
          sudo apt-get update
          sudo apt-get -y install curl jq
        }

    - name: Initializing
      working-directory: ./${{ env.CUR_REPO_NAME }}
      run: |
        bash ./scripts/init_env_stage1.sh

    - name: Restore SDK
      if: matrix.sdk
      uses: actions/cache/restore@v4
      id: cache-sdk
      with:
        path: ${{ env.CHCHE_SDK_PATH }}
        key: ${{ env.CHCHE_SDK_KEY }}
        lookup-only: true

    - if: matrix.sdk && steps.cache-sdk.outputs.cache-hit != 'true'
      run: |
        curl -fkLOZ --compressed --connect-timeout 10 --retry 5 "${USE_SDK_URL}/${USE_SDK_FILE}"
        sha256sum --check --status ./${CUR_REPO_NAME}/sdk.sha256sums || exit 1

    - name: Save SDK
      if: matrix.sdk && steps.cache-sdk.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: ${{ env.CHCHE_SDK_PATH }}
        key: ${{ env.CHCHE_SDK_KEY }}

    - name: Restore Custom rootfs
      if: matrix.rootfs && env.CUR_RUNTIME_TEST
      uses: actions/cache/restore@v4
      id: cache-rootfs-files
      with:
        path: ${{ env.CHCHE_ROOTFS_PATH }}
        key: ${{ env.CHCHE_ROOTFS_KEY }}
        lookup-only: true

    - if: env.CUR_RUNTIME_TEST && matrix.rootfs && steps.cache-rootfs-files.outputs.cache-hit != 'true' && env.CUR_USE_IMAGEBUILDER == 'true'
      id: download-ib
      run: curl -fkLOZ --compressed --connect-timeout 10 --retry 5 "${USE_IMAGEBUILDER_URL}/${USE_IMAGEBUILDER_FILE}"

    - name: Generate custom rootfs docker
      if: steps.download-ib.outcome == 'success'
      run: |
        sha256sum --check --status ./${CUR_REPO_NAME}/imagebuilder.sha256sums || exit 1
        mkdir -p "${CUR_IB_DIR_NAME}"
        XZ_OPT='-T0' tar -xJf "${USE_IMAGEBUILDER_FILE}" --strip-components=1 -C "${CUR_IB_DIR_NAME}"
        # Generate rootfs by imagebuilder
        bash ${CUR_REPO_NAME}/scripts/build_rootfs.sh

    - if: env.CUR_RUNTIME_TEST && matrix.rootfs && steps.cache-rootfs-files.outputs.cache-hit != 'true' && env.CUR_USE_IMAGEBUILDER != 'true'
      run: |
        curl -fkLOZ --compressed --connect-timeout 10 --retry 5 "${USE_ROOTFS_URL}/${USE_ROOTFS_FILE}"
        sha256sum --check --status ./${CUR_REPO_NAME}/rootfs.sha256sums || exit 1
        mkdir -p ./${CUR_REPO_NAME}/docker/custom/rootfs
        XZ_OPT='-T0' tar -xf "${USE_ROOTFS_FILE}" --strip-components=1 -C ./${CUR_REPO_NAME}/docker/custom/rootfs

    - name: Save Custom rootfs
      if: env.CUR_RUNTIME_TEST && matrix.rootfs && steps.cache-rootfs-files.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: ${{ env.CHCHE_ROOTFS_PATH }}
        key: ${{ env.CHCHE_ROOTFS_KEY }}

    - name: Upload Envs
      uses: actions/upload-artifact@v4
      with:
        name: cache-envs
        path: ./${{ env.CUR_REPO_NAME }}/${{ matrix.target }}-${{ matrix.link }}

  build-matrix:
    name: ${{ matrix.link }}, ${{ matrix.target }}, qt${{ matrix.qt }}, lt_${{ matrix.lt }}
    needs: [build-prep, download-sdk]
    env:
      CUR_LIBT_VERSION: ${{ matrix.lt }}
      CUR_LINK_TYPE: ${{ matrix.link }}
      CUR_QT_VERSION: ${{ matrix.qt }}
      CUR_TARGET_NAME: ${{ matrix.target }}
      CUR_REPO_NAME: auto-build
      CUR_QBT_REPO_NAME: qt_repo
      CUR_SDK_DIR_NAME: build
      CUR_LOCAL_REPO_NAME: local
      CUR_QBT_BRANCH: ${{ github.event.inputs.qbt }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.build-prep.outputs.matrix) }}
    steps:
    - uses: actions/checkout@v4
      with:
        path: ${{ env.CUR_REPO_NAME }}
        persist-credentials: false

    - name: Install Dependencies
      run: |
        [ -n "$(command -v curl)" -a -n "$(command -v jq)" ] || {
          sudo apt-get update
          sudo apt-get -y install curl jq
        }

    - name: Download Env
      uses: actions/download-artifact@v4
      with:
        name: cache-envs
        path: ./${{ env.CUR_REPO_NAME }}/cache-envs

    - name: Initializing
      working-directory: ./${{ env.CUR_REPO_NAME }}
      run: |
        . cache-envs/${CUR_TARGET_NAME}-${CUR_LINK_TYPE}
        cat cache-envs/${CUR_TARGET_NAME}-${CUR_LINK_TYPE} >> ${GITHUB_ENV}
        echo "USE_SDK_REVISION=${CHCHE_SDK_KEY##*-}" >> ${GITHUB_ENV}
        USE_QEMU_CPU=$(jq -c '.openwrt."'${CUR_TARGET_NAME}'".USE_QEMU_CPU? // empty' ${CUR_LINK_TYPE}.json)
        [ -n "${USE_QEMU_CPU}" ] && echo "QEMU_CPU=${USE_QEMU_CPU}" >> ${GITHUB_WORKSPACE}/docker_env || touch ${GITHUB_WORKSPACE}/docker_env
        bash ./scripts/init_env_stage2.sh

    - name: Restore SDK
      uses: actions/cache/restore@v4
      with:
        path: ${{ env.CHCHE_SDK_PATH }}
        key: ${{ env.CHCHE_SDK_KEY }}
        fail-on-cache-miss: true

    - run: |
        mkdir -p "${CUR_SDK_DIR_NAME}"
        XZ_OPT='-T0' tar -xJf "${CHCHE_SDK_PATH}" --strip-components=1 -C "${CUR_SDK_DIR_NAME}"

    - name: Restore feeds
      id: cache-feeds
      uses: actions/cache/restore@v4
      with:
        path: ${{ env.CUR_SDK_DIR_NAME }}/feeds/*
        key: feeds-${{ matrix.link }}-${{ env.USE_FEEDS_REVISION }}
        restore-keys: |
          feeds-${{ matrix.link }}-
          feeds-

    - name: Clone qbittorrent
      uses: actions/checkout@v4
      with:
        ref: ${{ env.USE_QBT_REF }}
        repository: ${{ github.repository_owner }}/SomePackages
        fetch-depth: 0
        token: ${{ secrets.SUPER_TOKEN }}
        path: ${{ env.CUR_QBT_REPO_NAME }}

    - if: env.USE_LIBT_REF != '' && env.USE_LIBT_REF != env.USE_QBT_REF
      run: |
        cd ${CUR_QBT_REPO_NAME}
        git restore -s origin/${USE_LIBT_REF} -- packages/libs/libtorrent-rasterbar

    - name: Prepare modified packages
      run: |
        bash ./${CUR_REPO_NAME}/scripts/build_pre.sh

    - name: Prepare building
      id: pre-build
      env:
        IGNORE_UPDATE_FEEDS: ${{ steps.cache-feeds.outputs.cache-hit }}
      working-directory: ./${{ env.CUR_SDK_DIR_NAME }}
      run: |
        bash ../${CUR_REPO_NAME}/scripts/build_conf.sh

    - name: Save feeds
      if: steps.cache-feeds.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: ${{ env.CUR_SDK_DIR_NAME }}/feeds/*
        key: ${{ steps.cache-feeds.outputs.cache-primary-key }}

    - name: Restore binary
      if: needs.build-prep.outputs.draft == 'success' || github.event.inputs.build == 'true'
      id: cache-bin
      uses: actions/cache/restore@v4
      with:
        path: |
          qbittorrent_${{ matrix.target }}
          ${{ env.CUR_SDK_DIR_NAME }}/logs
        key: ${{ format('bin-{0}-{1}-{2}-{3}-{4}', matrix.link, matrix.target, env.USE_SDK_REVISION, env.USE_LIBT_HASH, steps.pre-build.outputs.bin-hash) }}

    - name: Restore downloaded source files (exclude Qt)
      if: steps.cache-bin.outcome == 'success' && steps.cache-bin.outputs.cache-hit != 'true'
      id: restore-dl
      uses: actions/cache/restore@v4
      with:
        path: |
          ${{ env.CUR_SDK_DIR_NAME }}/dl/*
          !${{ env.CUR_SDK_DIR_NAME }}/dl/libtorrent-rasterbar-*.tar.xz
          !${{ env.CUR_SDK_DIR_NAME }}/dl/qtbase-*.tar.xz
          !${{ env.CUR_SDK_DIR_NAME }}/dl/qttools-*.tar.xz
        key: source-${{ matrix.link }}-${{ steps.pre-build.outputs.src-hash }}
        restore-keys: |
          source-${{ matrix.link }}-
          source-

    - name: Restore Qt source
      if: steps.cache-bin.outcome == 'success' && steps.cache-bin.outputs.cache-hit != 'true'
      id: restore-qt
      uses: actions/cache/restore@v4
      with:
        path: |
          ${{ env.CUR_SDK_DIR_NAME }}/dl/qtbase-*-src-${{ steps.pre-build.outputs.qt-version }}.tar.xz
          ${{ env.CUR_SDK_DIR_NAME }}/dl/qttools-*-src-${{ steps.pre-build.outputs.qt-version }}.tar.xz
        key: qt-${{ steps.pre-build.outputs.qt-version }}

    - name: Download pkgs
      if: (steps.restore-dl.outcome == 'success' && steps.restore-dl.outputs.cache-hit != 'true') || (steps.restore-qt.outcome == 'success' && steps.restore-qt.outputs.cache-hit != 'true')
      working-directory: ./${{ env.CUR_SDK_DIR_NAME }}
      run: |
        # Disable downloading default installed packages
        sed -i '/config \(DEFAULT_[^\(TARGET\)]\|MODULE_DEFAULT_\|PACKAGE_\)/{:a;N;/\n$/!ba;s/\(default\) \(y\|m\)/\1 n/g}' Config-build.in

        echo "::group::make defconfig"
        make defconfig
        echo "::endgroup::"
        echo "::group::Downloading..."
        make package/download V=sc -j$(($(nproc)+1))
        make package/qttools/download V=sc -j$(($(nproc)+1))
        echo "::endgroup::"

        # Clean up the obsolete packages
        if [ -d "./dl" ]; then
        	./scripts/dl_cleanup.py dl 2>/dev/null
        	rm -rf dl/libtorrent-rasterbar-*.tar.gz
        fi

    - name: Save downloaded source files (exclude Qt)
      if: steps.restore-dl.outcome == 'success' && steps.restore-dl.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ${{ env.CUR_SDK_DIR_NAME }}/dl/*
          !${{ env.CUR_SDK_DIR_NAME }}/dl/libtorrent-rasterbar-*.tar.xz
          !${{ env.CUR_SDK_DIR_NAME }}/dl/qtbase-*.tar.xz
          !${{ env.CUR_SDK_DIR_NAME }}/dl/qttools-*.tar.xz
        key: ${{ steps.restore-dl.outputs.cache-primary-key }}

    - name: Save Qt source
      if: steps.restore-qt.outcome == 'success' && steps.restore-qt.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ${{ env.CUR_SDK_DIR_NAME }}/dl/qtbase-*-src-${{ steps.pre-build.outputs.qt-version }}.tar.xz
          ${{ env.CUR_SDK_DIR_NAME }}/dl/qttools-*-src-${{ steps.pre-build.outputs.qt-version }}.tar.xz
        key: ${{ steps.restore-qt.outputs.cache-primary-key }}

    - name: Build the Binary Files
      if: (needs.build-prep.outputs.draft == 'success' || github.event.inputs.build == 'true') && steps.cache-bin.outputs.cache-hit != 'true'
      working-directory: ./${{ env.CUR_SDK_DIR_NAME }}
      run: |
        set -o pipefail

        echo "::group::make defconfig"
        make defconfig
        echo "::endgroup::"

        echo "::group::Buding"
        make package/luci-app-qbittorrent/compile V=sc -j$(($(nproc)+1)) BUILD_LOG=1 | grep -P "(^make\[\d+\]: ((Entering|Leaving) directory|\*\*\* .*Error).*|^time:.*|ERROR: .* failed to build\.)"
        echo "::endgroup::"

    - name: Pack all the flies
      id: pack-all
      if: success() || failure()
      env:
        CACHE_HIT: ${{ steps.cache-bin.outputs.cache-hit }}
      run: |
        bash ./${CUR_REPO_NAME}/scripts/pack_all.sh

    - name: Save binary
      if: steps.cache-bin.outcome == 'success' && steps.cache-bin.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          qbittorrent_${{ matrix.target }}
          ${{ env.CUR_SDK_DIR_NAME }}/logs
        key: ${{ steps.cache-bin.outputs.cache-primary-key }}

    - name: Upload Pkgs
      if: needs.build-prep.outputs.draft != 'success' && steps.pack-all.outputs.pkgs == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.target }}-${{ matrix.link }}-qt${{ matrix.qt }}-lt_${{ matrix.lt }}-pkgs_${{ github.run_attempt }}
        path: ${{ env.SAVED_NAME }}.tar.xz

    - name: Upload sha256sums
      if: steps.pack-all.outputs.pkgs == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: sha256sum-${{ matrix.target }}-${{ matrix.link }}-${{ matrix.qt }}-${{ matrix.lt }}-${{ github.run_attempt }}
        path: ${{ env.SAVED_NAME }}.sha256sum

    - name: Upload Logs
      if: (success() || failure()) && steps.pack-all.outputs.logs == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.target }}-${{ matrix.link }}-qt${{ matrix.qt }}-lt_${{ matrix.lt }}-logs_${{ github.run_attempt }}
        path: ${{ env.SAVED_NAME }}.logs.tar.xz

    - name: Restore Custom rootfs
      if: matrix.runtime_test
      uses: actions/cache/restore@v4
      with:
        path: ${{ env.CHCHE_ROOTFS_PATH }}
        key: ${{ env.CHCHE_ROOTFS_KEY }}
        fail-on-cache-miss: true

    - name: Build Custom Docker Container
      if: matrix.runtime_test
      run: |
        docker build -t test-container ./${CUR_REPO_NAME}/docker/custom

    - name: Register QEMU
      if: matrix.runtime_test
      run: |
        bash ./${CUR_REPO_NAME}/scripts/register_qemu.sh

    - name: Test via Docker container
      if: matrix.runtime_test
      run: |
        bash ./${CUR_REPO_NAME}/docker/docker_test.sh

    - name: Upload Release Asset
      id: upload-release
      if: needs.build-prep.outputs.draft == 'success' && steps.pack-all.outputs.pkgs == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        [ -n "$(find -L ${SAVED_NAME} -type f -iname '*qbittorrent*')" ] || exit 1
        cd ${CUR_REPO_NAME}
        gh release upload "${GITHUB_REF_NAME}" "../${SAVED_NAME}.tar.xz" --clobber

  pre-release:
    needs: [build-prep, build-matrix]
    runs-on: ubuntu-latest
    steps:
    - name: Clone Current Repository
      uses: actions/checkout@v4

    - run: npm i @actions/artifact@2.0.1

    - uses: actions/github-script@v7
      env:
        githubToken: ${{ secrets.GITHUB_TOKEN }}
      with:
        script: |
          const { DefaultArtifactClient } = require('@actions/artifact');
          const artifactClient = new DefaultArtifactClient();
          const findBy = {
          	token: process.env['githubToken'],
          	workflowRunId: context.runId,
          	repositoryOwner: context.repo.owner,
          	repositoryName: context.repo.repo
          }
          const { artifacts } = await artifactClient.listArtifacts({findBy});
          let jobs = [];
          for (const artifact of artifacts) {
          	if (!artifact.name.match(/sha256sum-\S+/g))
          		continue;

          	jobs.push((async () => {
          		await artifactClient.downloadArtifact(artifact.id, {
          			path: process.env['GITHUB_WORKSPACE'] + '/hash'
          		});
          		await github.rest.actions.deleteArtifact({
          			owner: context.repo.owner,
          			repo: context.repo.repo,
          			artifact_id: artifact.id,
          		});
          	})());
          }
          Promise.all(jobs);

    - run: |
        > sha256sums
        for sha256sum in hash/*.sha256sum; do
        	[ ! -f "${sha256sum}" ] || cat $sha256sum >> sha256sums
        done
        cat sha256sums

    - name: Upload sha256sum
      uses: actions/upload-artifact@v4
      with:
        name: sha256sums
        path: sha256sums

    - name: Edit Release Status
      if: needs.build-prep.outputs.draft == 'success'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gzip sha256sums
        gh release upload "${GITHUB_REF_NAME}" sha256sums.gz --clobber
        gh release edit "${GITHUB_REF_NAME}" --draft=false --prerelease
