From 212cdfc9cde240cb6ca2164d4eeb2a381c30eba8 Mon Sep 17 00:00:00 2001
From: Chocobo1 <Chocobo1@users.noreply.github.com>
Date: Wed, 8 Sep 2021 02:09:14 +0800
Subject: [PATCH] Migrate to OpenSSL EVP interface for hashing

The low-level interface is deprecated since OpenSSL v3.0 [1].

[1] https://www.openssl.org/docs/manmaster/man7/migration_guide.html "Deprecated low-level digest functions"
---
 include/libtorrent/aux_/hasher512.hpp |  10 +--
 include/libtorrent/hasher.hpp         |  10 ++-
 src/ed25519/hasher512.cpp             |  57 ++++++++++++---
 src/hasher.cpp                        | 100 +++++++++++++++++++++++---
 test/test_hasher.cpp                  |  23 ++++++
 test/test_hasher512.cpp               |  14 ++++
 6 files changed, 191 insertions(+), 23 deletions(-)

--- a/include/libtorrent/aux_/hasher512.hpp
+++ b/include/libtorrent/aux_/hasher512.hpp
@@ -56,9 +56,9 @@ POSSIBILITY OF SUCH DAMAGE.
 
 #elif defined TORRENT_USE_LIBCRYPTO
 
-	extern "C" {
-	#include <openssl/sha.h>
-	}
+extern "C" {
+#include <openssl/evp.h>
+}
 
 #else
 #include "libtorrent/aux_/sha512.hpp"
@@ -96,6 +96,8 @@ namespace aux {
 		explicit hasher512(span<char const> data);
 		hasher512(hasher512 const&);
 		hasher512& operator=(hasher512 const&) &;
+		hasher512(hasher512&&);
+		hasher512& operator=(hasher512&&) &;
 
 		// append the following bytes to what is being hashed
 		hasher512& update(span<char const> data);
@@ -122,7 +124,7 @@ namespace aux {
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		aux::crypt_hash<CALG_SHA_512, PROV_RSA_AES> m_context;
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA512_CTX m_context;
+		EVP_MD_CTX *m_context = nullptr;
 #else
 		sha512_ctx m_context;
 #endif
--- a/include/libtorrent/hasher.hpp
+++ b/include/libtorrent/hasher.hpp
@@ -63,7 +63,7 @@ POSSIBILITY OF SUCH DAMAGE.
 #elif defined TORRENT_USE_LIBCRYPTO
 
 extern "C" {
-#include <openssl/sha.h>
+#include <openssl/evp.h>
 }
 
 #else
@@ -104,6 +104,8 @@ TORRENT_CRYPTO_NAMESPACE
 		explicit hasher(span<char const> data);
 		hasher(hasher const&);
 		hasher& operator=(hasher const&) &;
+		hasher(hasher&&);
+		hasher& operator=(hasher&&) &;
 
 		// append the following bytes to what is being hashed
 		hasher& update(span<char const> data);
@@ -131,7 +133,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI
 		aux::crypt_hash<CALG_SHA1, PROV_RSA_FULL> m_context;
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA_CTX m_context;
+		EVP_MD_CTX *m_context = nullptr;
 #else
 		sha1_ctx m_context;
 #endif
@@ -148,6 +150,8 @@ TORRENT_CRYPTO_NAMESPACE
 		explicit hasher256(span<char const> data);
 		hasher256(hasher256 const&);
 		hasher256& operator=(hasher256 const&) &;
+		hasher256(hasher256&&);
+		hasher256& operator=(hasher256&&) &;
 
 		// append the following bytes to what is being hashed
 		hasher256& update(span<char const> data);
@@ -173,7 +177,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		aux::crypt_hash<CALG_SHA_256, PROV_RSA_AES> m_context;
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA256_CTX m_context;
+		EVP_MD_CTX *m_context = nullptr;
 #else
 		sha256_ctx m_context;
 #endif
--- a/src/ed25519/hasher512.cpp
+++ b/src/ed25519/hasher512.cpp
@@ -33,7 +33,10 @@ POSSIBILITY OF SUCH DAMAGE.
 #include "libtorrent/aux_/hasher512.hpp"
 #include "libtorrent/error_code.hpp"
 #include "libtorrent/assert.hpp"
-#include "libtorrent/ssl.hpp"
+
+#if defined TORRENT_USE_LIBCRYPTO
+#include <openssl/opensslv.h> // for OPENSSL_VERSION_NUMBER
+#endif
 
 #include "libtorrent/aux_/disable_deprecation_warnings_push.hpp"
 
@@ -49,7 +52,12 @@ namespace aux {
 #elif TORRENT_USE_CNG
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA512_Init(&m_context);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		m_context = EVP_MD_CTX_new();
+#else
+		m_context = EVP_MD_CTX_create();
+#endif
+		EVP_DigestInit_ex(m_context, EVP_sha512(), nullptr);
 #else
 		SHA512_init(&m_context);
 #endif
@@ -74,11 +82,40 @@ namespace aux {
 		gcry_md_copy(&m_context, h.m_context);
 		return *this;
 	}
+#elif defined TORRENT_USE_LIBCRYPTO
+	hasher512::hasher512(hasher512 const& h)
+		: hasher512()
+	{
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+	}
+
+	hasher512& hasher512::operator=(hasher512 const& h) &
+	{
+		if (this == &h) return *this;
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+		return *this;
+	}
 #else
 	hasher512::hasher512(hasher512 const&) = default;
 	hasher512& hasher512::operator=(hasher512 const&) & = default;
 #endif
 
+#if defined TORRENT_USE_LIBCRYPTO
+	hasher512::hasher512(hasher512&& h)
+	{
+		std::swap(m_context, h.m_context);
+	}
+
+	hasher512& hasher512::operator=(hasher512&& h) &
+	{
+		std::swap(m_context, h.m_context);
+		return *this;
+	}
+#else
+	hasher512::hasher512(hasher512&&) = default;
+	hasher512& hasher512::operator=(hasher512&&) & = default;
+#endif
+
 	hasher512& hasher512::update(span<char const> data)
 	{
 		TORRENT_ASSERT(data.size() > 0);
@@ -91,7 +128,7 @@ namespace aux {
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.update(data);
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA512_Update(&m_context, reinterpret_cast<unsigned char const*>(data.data())
+		EVP_DigestUpdate(m_context, reinterpret_cast<unsigned char const*>(data.data())
 			, static_cast<std::size_t>(data.size()));
 #else
 		SHA512_update(&m_context, reinterpret_cast<unsigned char const*>(data.data())
@@ -113,7 +150,7 @@ namespace aux {
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.get_hash(digest.data(), digest.size());
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA512_Final(reinterpret_cast<unsigned char*>(digest.data()), &m_context);
+		EVP_DigestFinal_ex(m_context, reinterpret_cast<unsigned char*>(digest.data()), nullptr);
 #else
 		SHA512_final(reinterpret_cast<unsigned char*>(digest.data()), &m_context);
 #endif
@@ -131,20 +168,24 @@ namespace aux {
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.reset();
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA512_Init(&m_context);
+		EVP_DigestInit_ex(m_context, EVP_sha512(), nullptr);
 #else
 		SHA512_init(&m_context);
 #endif
 	}
 
-#if defined TORRENT_USE_LIBGCRYPT
 	hasher512::~hasher512()
 	{
+#if defined TORRENT_USE_LIBGCRYPT
 		gcry_md_close(m_context);
-	}
+#elif defined TORRENT_USE_LIBCRYPTO
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		if (m_context) EVP_MD_CTX_free(m_context);
 #else
-	hasher512::~hasher512() = default;
+		if (m_context) EVP_MD_CTX_destroy(m_context);
+#endif
 #endif
+	}
 
 }
 }
--- a/src/hasher.cpp
+++ b/src/hasher.cpp
@@ -40,6 +40,10 @@ POSSIBILITY OF SUCH DAMAGE.
 
 #include "libtorrent/aux_/disable_deprecation_warnings_push.hpp"
 
+#if defined TORRENT_USE_LIBCRYPTO
+#include <openssl/opensslv.h> // for OPENSSL_VERSION_NUMBER
+#endif
+
 namespace libtorrent {
 
 TORRENT_CRYPTO_NAMESPACE
@@ -53,7 +57,12 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CNG
 #elif TORRENT_USE_CRYPTOAPI
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA1_Init(&m_context);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		m_context = EVP_MD_CTX_new();
+#else
+		m_context = EVP_MD_CTX_create();
+#endif
+		EVP_DigestInit_ex(m_context, EVP_sha1(), nullptr);
 #else
 		SHA1_init(&m_context);
 #endif
@@ -85,11 +94,40 @@ TORRENT_CRYPTO_NAMESPACE
 		gcry_md_copy(&m_context, h.m_context);
 		return *this;
 	}
+#elif defined TORRENT_USE_LIBCRYPTO
+	hasher::hasher(hasher const& h)
+		: hasher()
+	{
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+	}
+
+	hasher& hasher::operator=(hasher const& h) &
+	{
+		if (this == &h) return *this;
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+		return *this;
+	}
 #else
 	hasher::hasher(hasher const&) = default;
 	hasher& hasher::operator=(hasher const&) & = default;
 #endif
 
+#if defined TORRENT_USE_LIBCRYPTO
+	hasher::hasher(hasher&& h)
+	{
+		std::swap(m_context, h.m_context);
+	}
+
+	hasher& hasher::operator=(hasher&& h) &
+	{
+		std::swap(m_context, h.m_context);
+		return *this;
+	}
+#else
+	hasher::hasher(hasher&&) = default;
+	hasher& hasher::operator=(hasher&&) & = default;
+#endif
+
 	hasher& hasher::update(char const* data, int len)
 	{
 		return update({data, len});
@@ -107,7 +145,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI
 		m_context.update(data);
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA1_Update(&m_context, reinterpret_cast<unsigned char const*>(data.data())
+		EVP_DigestUpdate(m_context, reinterpret_cast<unsigned char const*>(data.data())
 			, static_cast<std::size_t>(data.size()));
 #else
 		SHA1_update(&m_context, reinterpret_cast<unsigned char const*>(data.data())
@@ -129,7 +167,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI
 		m_context.get_hash(digest.data(), digest.size());
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA1_Final(reinterpret_cast<unsigned char*>(digest.data()), &m_context);
+		EVP_DigestFinal_ex(m_context, reinterpret_cast<unsigned char*>(digest.data()), nullptr);
 #else
 		SHA1_final(reinterpret_cast<unsigned char*>(digest.data()), &m_context);
 #endif
@@ -147,7 +185,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI
 		m_context.reset();
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA1_Init(&m_context);
+		EVP_DigestInit_ex(m_context, EVP_sha1(), nullptr);
 #else
 		SHA1_init(&m_context);
 #endif
@@ -157,6 +195,12 @@ TORRENT_CRYPTO_NAMESPACE
 	{
 #if defined TORRENT_USE_LIBGCRYPT
 		gcry_md_close(m_context);
+#elif defined TORRENT_USE_LIBCRYPTO
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		if (m_context) EVP_MD_CTX_free(m_context);
+#else
+		if (m_context) EVP_MD_CTX_destroy(m_context);
+#endif
 #endif
 	}
 
@@ -169,7 +213,12 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CNG
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA256_Init(&m_context);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		m_context = EVP_MD_CTX_new();
+#else
+		m_context = EVP_MD_CTX_create();
+#endif
+		EVP_DigestInit_ex(m_context, EVP_sha256(), nullptr);
 #else
 		SHA256_init(m_context);
 #endif
@@ -201,11 +250,40 @@ TORRENT_CRYPTO_NAMESPACE
 		gcry_md_copy(&m_context, h.m_context);
 		return *this;
 	}
+#elif defined TORRENT_USE_LIBCRYPTO
+	hasher256::hasher256(hasher256 const& h)
+		: hasher256()
+	{
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+	}
+
+	hasher256& hasher256::operator=(hasher256 const& h) &
+	{
+		if (this == &h) return *this;
+		EVP_MD_CTX_copy_ex(m_context, h.m_context);
+		return *this;
+	}
 #else
 	hasher256::hasher256(hasher256 const&) = default;
 	hasher256& hasher256::operator=(hasher256 const&) & = default;
 #endif
 
+#if defined TORRENT_USE_LIBCRYPTO
+	hasher256::hasher256(hasher256&& h)
+	{
+		std::swap(m_context, h.m_context);
+	}
+
+	hasher256& hasher256::operator=(hasher256&& h) &
+	{
+		std::swap(m_context, h.m_context);
+		return *this;
+	}
+#else
+	hasher256::hasher256(hasher256&&) = default;
+	hasher256& hasher256::operator=(hasher256&&) & = default;
+#endif
+
 	hasher256& hasher256::update(char const* data, int len)
 	{
 		return update({ data, len });
@@ -223,7 +301,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.update(data);
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA256_Update(&m_context, reinterpret_cast<unsigned char const*>(data.data())
+		EVP_DigestUpdate(m_context, reinterpret_cast<unsigned char const*>(data.data())
 			, static_cast<std::size_t>(data.size()));
 #else
 		SHA256_update(m_context, reinterpret_cast<unsigned char const*>(data.data())
@@ -245,7 +323,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.get_hash(digest.data(), digest.size());
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA256_Final(reinterpret_cast<unsigned char*>(digest.data()), &m_context);
+		EVP_DigestFinal_ex(m_context, reinterpret_cast<unsigned char*>(digest.data()), nullptr);
 #else
 		SHA256_final(reinterpret_cast<unsigned char*>(digest.data()), m_context);
 #endif
@@ -263,7 +341,7 @@ TORRENT_CRYPTO_NAMESPACE
 #elif TORRENT_USE_CRYPTOAPI_SHA_512
 		m_context.reset();
 #elif defined TORRENT_USE_LIBCRYPTO
-		SHA256_Init(&m_context);
+		EVP_DigestInit_ex(m_context, EVP_sha256(), nullptr);
 #else
 		SHA256_init(m_context);
 #endif
@@ -273,6 +351,12 @@ TORRENT_CRYPTO_NAMESPACE
 	{
 #if defined TORRENT_USE_LIBGCRYPT
 		gcry_md_close(m_context);
+#elif defined TORRENT_USE_LIBCRYPTO
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		if (m_context) EVP_MD_CTX_free(m_context);
+#else
+		if (m_context) EVP_MD_CTX_destroy(m_context);
+#endif
 #endif
 	}
 
--- a/test/test_hasher.cpp
+++ b/test/test_hasher.cpp
@@ -84,6 +84,20 @@ void test_vector(string_view s, string_v
 	TEST_EQUAL(output_hex, digest_hex);
 }
 
+template<typename T>
+void test_move(string_view const input)
+{
+	std::string const digest = T(input).final().to_string();
+
+	T tmp1(input);
+	T h1(std::move(tmp1));
+	TEST_EQUAL(h1.final().to_string(), digest);
+
+	T tmp2(input);
+	T h2 = std::move(tmp2);
+	TEST_EQUAL(h2.final().to_string(), digest);
+}
+
 }
 
 TORRENT_TEST(hasher)
@@ -100,6 +114,11 @@ TORRENT_TEST(hasher)
 	}
 }
 
+TORRENT_TEST(hasher_move)
+{
+	test_move<hasher>("abc");
+}
+
 // http://www.di-mgt.com.au/sha_testvectors.html
 TORRENT_TEST(hasher_test_vec1)
 {
@@ -144,3 +163,7 @@ TORRENT_TEST(hasher256)
 	}
 }
 
+TORRENT_TEST(hasher256_move)
+{
+	test_move<hasher256>("abc");
+}
--- a/test/test_hasher512.cpp
+++ b/test/test_hasher512.cpp
@@ -89,4 +89,18 @@ TORRENT_TEST(hasher512_test_vec1)
 	);
 }
 
+TORRENT_TEST(hasher512_move)
+{
+	std::string const input = "abc";
+	std::string const digest = aux::hasher512(input).final().to_string();
+
+	aux::hasher512 tmp1(input);
+	aux::hasher512 h1(std::move(tmp1));
+	TEST_EQUAL(h1.final().to_string(), digest);
+
+	aux::hasher512 tmp2(input);
+	aux::hasher512 h2 = std::move(tmp2);
+	TEST_EQUAL(h2.final().to_string(), digest);
+}
+
 #endif // TORRENT_DISABLE_DHT
