--- a/src/ip_notifier.cpp
+++ b/src/ip_notifier.cpp
@@ -169,7 +169,8 @@ private:
 
 	struct local_address
 	{
-		int family;
+		std::uint8_t family;
+		std::uint8_t scope;
 		std::array<char, 16> data;
 	};
 	// maps if_index to the most recently advertised local address
@@ -189,27 +190,38 @@ private:
 
 			auto const* addr_msg = static_cast<ifaddrmsg const*>(nlmsg_data(nh));
 			std::uint32_t const index = addr_msg->ifa_index;
-			int const family = addr_msg->ifa_family;
+			std::uint8_t const family = addr_msg->ifa_family;
+			std::uint8_t const scope = addr_msg->ifa_scope;
 			std::size_t attr_len = ifa_payload(nh);
 			auto const* rta_ptr = ifa_rta(addr_msg);
+			auto& existing = m_state[index];
+			std::size_t const address_len = family == AF_INET ? 4 : 16;
+			const void* address = nullptr;
 
 			for (; rta_ok(rta_ptr, attr_len); rta_ptr = rta_next(rta_ptr, attr_len))
 			{
-				auto* const ptr = rta_data(rta_ptr);
-				if (rta_ptr->rta_type != IFA_LOCAL)
+				if (rta_ptr->rta_type != IFA_LOCAL && rta_ptr->rta_type != IFA_ADDRESS)
 					continue;
 
-				auto& existing = m_state[index];
-				std::size_t const address_len = family == AF_INET ? 4 : 16;
-				if (existing.family == family
+				auto* const ptr = rta_data(rta_ptr);
+				if (existing.family == family && existing.scope == scope
 					&& std::memcmp(&existing.data, ptr, address_len) == 0)
 				{
 					break;
 				}
 
-				existing.family = family;
-				std::memcpy(existing.data.data(), ptr, address_len);
+				address = ptr;
 				pertinent = true;
+
+				if (rta_ptr->rta_type == IFA_LOCAL)
+					break;
+			}
+
+			if (pertinent)
+			{
+				existing.family = family;
+				existing.scope = scope;
+				std::memcpy(existing.data.data(), address, address_len);
 			}
 		}
 
